// SPDX-License-Identifier: MITpragma solidity ^0.8.17;import "@openzeppelin/contracts/token/ERC20/IERC20.sol";import "@openzeppelin/contracts/access/Ownable.sol";import "@openzeppelin/contracts/security/ReentrancyGuard.sol";/// @title SimpleSwap - swap-only constant-product AMM (no LP tokens)/// @notice Owner seeds the contract with initial reserves. Users can swap either way./// @dev Fee is 0.3% by default. All transfers return bool (ERC20).contract SimpleSwap is Ownable, ReentrancyGuard {    IERC20 public immutable token0;    IERC20 public immutable token1;    uint256 public reserve0; // token0 balance snapshot    uint256 public reserve1; // token1 balance snapshot    uint256 public constant FEE_NUM = 3;   // numerator for 0.3%    uint256 public constant FEE_DEN = 1000;    event Swap0For1(address indexed user, uint256 amount0In, uint256 amount1Out);    event Swap1For0(address indexed user, uint256 amount1In, uint256 amount0Out);    event Sync(uint256 reserve0, uint256 reserve1);    event Funded(address indexed by, uint256 added0, uint256 added1);    event Withdrawn(address indexed to, uint256 out0, uint256 out1);    constructor(address _token0, address _token1) {        require(_token0 != _token1, "Identical tokens");        require(_token0 != address(0) && _token1 != address(0), "Zero address");        token0 = IERC20(_token0);        token1 = IERC20(_token1);    }    /// @notice Owner-only: fund the pair with tokens (seed reserves or top up).    /// @dev Caller must approve tokens prior to calling.    function fund(uint256 amount0, uint256 amount1) external onlyOwner nonReentrant {        uint256 a0 = 0;        uint256 a1 = 0;        if (amount0 > 0) {            require(token0.transferFrom(msg.sender, address(this), amount0), "transfer0 failed");            a0 = amount0;        }        if (amount1 > 0) {            require(token1.transferFrom(msg.sender, address(this), amount1), "transfer1 failed");            a1 = amount1;        }        _updateReserves();        emit Funded(msg.sender, a0, a1);    }    /// @notice Owner-only: withdraw tokens from the contract.    function withdraw(address to, uint256 out0, uint256 out1) external onlyOwner nonReentrant {        if (out0 > 0) {            require(token0.transfer(to, out0), "transfer0 failed");        }        if (out1 > 0) {            require(token1.transfer(to, out1), "transfer1 failed");        }        _updateReserves();        emit Withdrawn(to, out0, out1);    }    /// @notice Swap token0 -> token1    /// @param amount0In amount of token0 user sends (must approve prior to call)    /// @param minAmount1Out minimum acceptable amount out (slippage protection)    function swap0For1(uint256 amount0In, uint256 minAmount1Out) external nonReentrant returns (uint256 amount1Out) {        require(amount0In > 0, "Zero input");        // transfer token0 in        require(token0.transferFrom(msg.sender, address(this), amount0In), "transfer0 failed");        // compute amountOut using Uniswap formula with fee        // amountInWithFee = amount0In * (FEE_DEN - FEE_NUM)        uint256 amountInWithFee = amount0In * (FEE_DEN - FEE_NUM);        // numerator = amountInWithFee * reserve1        // denominator = reserve0 * FEE_DEN + amountInWithFee        uint256 numerator = amountInWithFee * reserve1;        uint256 denominator = (reserve0 * FEE_DEN) + amountInWithFee;        require(denominator > 0, "Empty reserves");        amount1Out = numerator / denominator;        require(amount1Out >= minAmount1Out, "Slippage");        require(token1.transfer(msg.sender, amount1Out), "transfer1 failed");        _updateReserves();        emit Swap0For1(msg.sender, amount0In, amount1Out);    }    /// @notice Swap token1 -> token0    function swap1For0(uint256 amount1In, uint256 minAmount0Out) external nonReentrant returns (uint256 amount0Out) {        require(amount1In > 0, "Zero input");        require(token1.transferFrom(msg.sender, address(this), amount1In), "transfer1 failed");        uint256 amountInWithFee = amount1In * (FEE_DEN - FEE_NUM);        uint256 numerator = amountInWithFee * reserve0;        uint256 denominator = (reserve1 * FEE_DEN) + amountInWithFee;        require(denominator > 0, "Empty reserves");        amount0Out = numerator / denominator;        require(amount0Out >= minAmount0Out, "Slippage");        require(token0.transfer(msg.sender, amount0Out), "transfer0 failed");        _updateReserves();        emit Swap1For0(msg.sender, amount1In, amount0Out);    }    /// @notice Returns current reserves (fresh on-chain balances)    function getReserves() public view returns (uint256, uint256) {        return (token0.balanceOf(address(this)), token1.balanceOf(address(this)));    }    /// @dev Internal update: snapshot reserves from token balances    function _updateReserves() internal {        reserve0 = token0.balanceOf(address(this));        reserve1 = token1.balanceOf(address(this));        emit Sync(reserve0, reserve1);    }    /// @notice Convenience: view expected output for token0 -> token1 (does not mutate)    function quote0To1(uint256 amount0In) external view returns (uint256 amount1Out) {        if (amount0In == 0) return 0;        uint256 r0 = reserve0;        uint256 r1 = reserve1;        uint256 amountInWithFee = amount0In * (FEE_DEN - FEE_NUM);        uint256 numerator = amountInWithFee * r1;        uint256 denominator = (r0 * FEE_DEN) + amountInWithFee;        if (denominator == 0) return 0;        return numerator / denominator;    }    /// @notice Convenience: view expected output for token1 -> token0    function quote1To0(uint256 amount1In) external view returns (uint256 amount0Out) {        if (amount1In == 0) return 0;        uint256 r0 = reserve0;        uint256 r1 = reserve1;        uint256 amountInWithFee = amount1In * (FEE_DEN - FEE_NUM);        uint256 numerator = amountInWithFee * r0;        uint256 denominator = (r1 * FEE_DEN) + amountInWithFee;        if (denominator == 0) return 0;        return numerator / denominator;    }}